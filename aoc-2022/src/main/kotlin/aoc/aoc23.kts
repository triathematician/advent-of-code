import aoc.AocParser.Companion.parselines
import aoc.AocRunner
import aoc.util.*
import java.lang.IllegalStateException
import java.util.*

val day = 23
val debug = false

val testInput = """
....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..
""".parselines.let { CharGrid(it) }

val input = """
..#.#.....#.#...#.#.###.#######.#.#..###.#.##..###.##..###.#...##.##....#
.#....#.#.###.#...#.#.#..#.###........#.#####.##........#..#...##..#.....
##..#...#.....#######.##..#..##.#..#.##...#.#.##......#...#.##.###.....#.
#.###.#..#...#..#####.#..#.##..#...####..#..#.##....###.#.##.#.####...##.
.#.##.###..#.##..#.#####.#.#.##.###.###......#..#...#.##.#.....#.##..#.#.
#....##.####.##..##.##.....#...##.##....###.#.#..##.#.#..####......##.##.
.....###.#..##.......######..###.###..##..#####.#.##.####.##...#.#.###.##
....#.####.#..##.####.#..#.#.#.##......###..##.#..##.#..##.###.##..#..#..
##.#.#######.#.#####...##..###.#.#.#.##..#......##...###.#.#.#####.#..#.#
#.#.####...#####.##..#.#...##..#.####..##..###....#.#.#####.#.###...#.#.#
.....#.#.#####...##............###...#..##..#.....#########.#.#.#####..##
.###.#...##.#.#....###.#..#..#....#...#.##.#...#.###.#..######.#.#.##...#
..#..#........#..#.##.#.#.#.#...###.##.#..###.#.#..#..#..#....##.###.##..
##..#.#..#...##...#.............######.#.##...####.##.####.#.########..#.
..#..##.##..#.##...#.....###.###.#..##.#.#...#....######..#...####..###.#
#####..##......#..#.#.###.#....##...#####...###.....#..#..#..##...#..##..
#..###..#..###...#......##.....#...###.....##.....##..#.....#...#........
######.......##.##.###.#...####...####.#.##.#..#.#.#...#.......#...##.#.#
#.#..#.####.......###...#..####....#.##.##.....##.#.###.#...#..##.####.#.
#..#.#..##.##....##.#.....##.#..####..#..#.#....#...#.#.#..#.###.#....##.
..#..###...#..##.#....##.....#####..#..#..#.#.#.#....#.##..#####.###..#.#
#.##.#..##..####...#.#.####...##.#.##.##.#...#.#.###..#...#.#.#######.#..
.#.#.##......#####.#..####.....#..#####.###.#..###.##...#..#.#....##.####
###.##.#.##...#..####..#..#.#...####.#####..#.###.##.##...###..###.###.#.
.#.###.#.##...##.....###.#.###..#.#...#.....##...###.#..####.##.#..#..##.
##.#.....#..##..#####...##..####..##.#####.#.##...###......##.##....##...
.#..###.#.##.###..#....##.##...##..#.###...#.######.###....#.##.###.#####
####.######.##...#.....#.#.#.#######.##..##..#.#####..#######.######..#..
#..#.#.##..###.#####.###.#.##..#.#....##.#..##......#.####.##..#.####..##
.##..##..#.###...#####.###.####.###..######.##.#....###...#.#..####...#..
.#######..###.###..###...#.####...#...#...#.#...#.#...#....#.#...#....##.
####.#..###.#.#.#.###..##..#.#....###...#...#......#...#.###.#..###..##.#
#.#.#...#######..##.#.#.#...########.#.##...#.##.##...####...##.##.#..###
#...#####...##...####.#.#.#.####....#.##.###.##.#.###..##.#.##..#.#..##.#
##.#.#.##..#..#...##..#.#..#.#.#.#..###.#.####.##..#####.#...#.##..###.##
.#.#...##.##.#..#.##....##.###.#....#..#...##..#.##..##..#..#.#..#..##...
.####.###..#...###.#..#.##..#.....##..##..##..#.#..#.#.#...###...#....###
.###..#...##.####..#...#..#......#..#...##...##.##.##..#.##.........#...#
.....##..##.#..#..####.#.####..#..##..#..##..#.#..###.#.#.#...###.....#.#
.....##.##.####...#.###...###...####....#.##.######.#..#....#.##.#.##.#..
###..##.#.....#...#.#.....###..###...##.#..###..######.....##.#...#.####.
##.#####.#.#.##.#.....#.##....##.#######.##.#..#...#.......#####.#..##.##
.##.###.#..##.#...#..#...##.##.#..#.##...##.####.#......#..####.....#..#.
.######.###.###.#..##.....#..#..#..#.#.#.###.##.#....#####.#..####......#
.####.#....##.#...#....#.#..#..#.####.#.#####..##..#.####..#.####.##.####
##....#.#.#####.######..###.###....###..#.####.#.#.##..##..###.....#..###
.#...##.#...#......#.#.#..###...###.#..#..###..########.##...#.#.#..#.#..
##..#.##.#.#..#.#....###...########.#.###.####...###..###.#....##..#.####
#.#.##.#.#....##..#.....##...#.#.###.##....#..##....#..####.##.###..##...
#..#.#.#.####.###.#..###.#...##.##....##.###....#..##.....###..#####.####
#.#.####...##.##..###....###..........#.###########..##..#...#.#.#..##.#.
.#..#.#.#######.###.###....#.##..#.#..##..##..#.#..##.#.##..#####.##.##..
..#.###.#.#.###.##.#..#.#.##.#.##.#.#...##.##.##.#...##...#.#.#.##.#.....
.#...#...#.##..##.##.#.##.#...#..########..####.#...#.###..###.#.####....
##.##....###.#.#....#.####..#.#.#.#.......#...#.#.##...##.##.#.#.#####.##
#..##########.###..#.##.###....#..#.#.##..#.#....#########.#..#.#.##..##.
####.####.#....#...#..#..###.###...#...##..##.##.###.###..####....###..##
.##.#...####..##.###.##..###..#..###.###.##...#..#......#.###..#.#.#.#..#
##.##.##.###.#..###..##.#.##.##....#.###.#####.####.###...#.#.#.######..#
....#..#.####.##...#.#####.....#####.#######.##..#.###..###...####.#...##
##.....##.#..####..####..#.#.#..#.#.##..#...###..#..#..#.##.#...#####.#.#
########.#....##.##.#.#.#.#.#..#..#.##...#......#.##.#.#.###......#....##
...#.####.#..#.#..#..#..##...#.....#############.##.#..###.......###.##.#
....#.#..#.#.##.#.#######.######...#..#..#..###.####..######.####.###..#.
..####.#...#..#.###.###...###..#.#...#.#..##.#####......#..#.########....
##.#.##..#.....#.....#.###..#..#.#.#.#.##.##..#.#..#.###.#..#....##...###
#.###...###.#..#.##.....###.....#.##..#.....#..##..#.##.#.#.#..#..#...#..
#.#..##..#.##....#..##.#.#.#.####.####.#.....###.#..#..##..##.###..##.#.#
#.#.##...#...##..#.###.#..##.##.....#.#..######....#....#.###.#.##....#.#
#.......##.##..#####.#..#.#.##.#.######...#....##.##...#...#.#.#.##.###..
##..#.##..#.#......#####....#..###..#.#.#....##.##.##....#..####...#.#.#.
.#.###.#..#####.##.###.#..#....###.##...#.#...##.#...##...#..###..#.#.###
#....#...#..#..##.##.##...####.#.#.#...#.#.#.##.#...#.##.........#.##.#..
""".parselines.let { CharGrid(it) }

class CharGrid(s: List<String>) {
    var space = s.map { it.toCharArray().toMutableList() }.toMutableList()
    init { growToFit() }

    val xrange
        get() = space[0].indices
    val yrange
        get() = space.indices

    override fun toString() = space.joinToString("\n") { String(it.toCharArray()) }

    fun get(x: Int, y: Int) = space[y][x]
    fun get(c: Coord) = space[c.y][c.x]

    fun findElves(): List<Coord> =
        xrange.flatMap { x -> yrange.map { y -> x to y }.filter { get(it) == '#' } }

    fun moveElves(firstDir: Dir): Boolean {
        val elves = findElves()
        val dirPref = DIRS.rotate(-firstDir)
        val proposed = elves.associateWith { e ->
            val moves = dirPref.mapNotNull { dir -> proposeMove(e, dir) }
            moves.firstOrNull() ?: e
        }.entries.groupBy { it.value }
            .filterValues { it.size == 1 && it[0].key != it[0].value }
        proposed.forEach { (_, moves) ->
            moveElf(moves[0].key, moves[0].value)
        }
        growToFit()
        if (debug) println("\n$this")
        return proposed.isNotEmpty()
    }

    fun moveElf(from: Coord, to: Coord) {
        if (get(from) != '#') throw IllegalStateException("Cannot move $from to $to")
        if (get(to) != '.') throw IllegalStateException("Cannot move $from to $to")
        space[from.y][from.x] = '.'
        space[to.y][to.x] = '#'
    }

    fun proposeMove(e: Coord, dir: Dir): Coord? {
        if (free(e.top, e.top.left, e.top.right, e.left, e.right, e.bottom, e.bottom.left, e.bottom.right)) return null
        return when (dir) {
            NORTH -> if (free(e.top, e.top.left, e.top.right)) e.top else null
            SOUTH -> if (free(e.bottom, e.bottom.left, e.bottom.right)) e.bottom else null
            WEST -> if (free(e.left, e.left.top, e.left.bottom)) e.left else null
            EAST -> if (free(e.right, e.right.top, e.right.bottom)) e.right else null
            else -> TODO()
        }
    }

    fun free(vararg loc: Coord) = loc.all { get(it.x, it.y) == '.' }

    fun elfLocs(): Pair<IntRange, IntRange> {
        val elves = findElves()
        val xWithElves = elves.map { it.x }.sorted().let { it.first()..it.last() }
        val yWithElves = elves.map { it.y }.sorted().let { it.first()..it.last() }
        return xWithElves to yWithElves
    }

    fun freeTiles(): Int {
        val locs = elfLocs()
        return locs.first.toList().size * locs.second.toList().size - findElves().size
    }

    fun growToFit() {
        val locs = elfLocs()
        if (locs.first.last == xrange.last) {
            space.forEach { it.add('.') }
        }
        if (locs.first.first == xrange.first) {
            space.forEach { it.add(0, '.') }
        }
        if (locs.second.last == yrange.last) {
            space.add(space[0].indices.map { '.' }.toMutableList())
        }
        if (locs.second.first == yrange.first) {
            space.add(0, space[0].indices.map { '.' }.toMutableList())
        }
    }
}

typealias Dir = Int
val NORTH = 0
val SOUTH = 1
val WEST = 2
val EAST = 3
val DIRS = listOf(NORTH, SOUTH, WEST, EAST)

fun <X> List<X>.rotate(n: Int) = toMutableList().also { Collections.rotate(it, n) }

// test case

var testResult = 0
val testResult2 = (0..100).first {
    val res = testInput.moveElves(it % 4)
    if (it == 9)
        testResult = testInput.freeTiles()
    !res
} + 1

// parts 1 and 2 combined

var answer1 = 0
val answer2 = (0..100000).first {
    val res = input.moveElves(it % 4)
    if (it == 9)
        answer1 = input.freeTiles()
    !res
} + 1

// print results

AocRunner(day,
    info = { listOf("Leaderboard: 21:46/24:43", "Answers: 4123/1029") },
    test = { "$testResult, $testResult2" },
    part1 = { answer1 },
    part2 = { answer2 }
).run()
